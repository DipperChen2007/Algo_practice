def merge(A, p, q, r):
    # A: 原数组
    # p, q, r: 下标（闭区间）
    # 假设：A[p:q] 和 A[q+1:r] 这两段已经各自排好序，现在要把它们合并成 A[p:r] 有序

    L = A[p:q+1]         # 把左半边复制出来：A[p] 到 A[q]（注意 Python 切片右端不包含，所以要 +1）
    R = A[q+1:r+1]       # 把右半边复制出来：A[q+1] 到 A[r]

    i = j = 0            # i 指向 L 当前还没合并的最小元素位置；j 指向 R 当前还没合并的最小元素位置
    k = p                # k 指向原数组 A 要写入的位置，从 p 开始写回

    while i < len(L) and j < len(R):   # 只要 L 和 R 都还有元素没用完，就持续比较、写回
        if L[i] <= R[j]:               # 如果左边当前元素更小（或相等）
            A[k] = L[i]                # 把 L[i] 写回到 A[k]
            i += 1                     # 左边指针右移，表示这个元素已经用掉
        else:                           # 否则右边更小
            A[k] = R[j]                # 把 R[j] 写回到 A[k]
            j += 1                     # 右边指针右移
        k += 1                         # 每写回一个元素，A 的写入位置也要右移一格

    while i < len(L):                  # 如果 R 先用完了，但 L 还有剩下的
        A[k] = L[i]                    # 直接把 L 剩余元素按顺序全部写回（因为 L 本来就有序）
        i += 1                         # 左边指针右移
        k += 1                         # 写入位置右移

    while j < len(R):                  # 如果 L 先用完了，但 R 还有剩下的
        A[k] = R[j]                    # 直接把 R 剩余元素按顺序全部写回
        j += 1                         # 右边指针右移
        k += 1                         # 写入位置右移


def merge_sort(A, p, r):
    # 对 A 的 p..r（闭区间）进行归并排序（原地修改 A，不 return）
    if p < r:                          # 只要区间长度 >= 2 才需要继续分治；长度为1就天然有序
        q = (p + r) // 2               # 取中点 q，把区间分成 [p..q] 和 [q+1..r]
        merge_sort(A, p, q)            # 递归排序左半边
        merge_sort(A, q + 1, r)        # 递归排序右半边
        merge(A, p, q, r)              # 左右都排好后，合并成 A[p..r] 的有序区间
